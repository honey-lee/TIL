## 📌 1. 데이터베이스 이상 현상

**데이터 이상 현상(anomaly) :** 데이터베이스에서 삽입, 업데이트, 삭제를 제대로 할 수 없게 되는 경우, 데이터 모델링을 제대로 하지 않았기 때문에 발생

1. **삽입 이상** : 새로운 데이터를 자연스럽게 저장할 수 없는 경우
2. **업데이트 이상** : 데이터를 업데이트했을 때 정확성을 지키기 어려워지는 경우
3. **삭제 이상** : 원하는 데이터만 자연스럽게 삭제할 수 없는 경우

## 📌 2. 정규화 (Normalization)

**정규화** : 데이터베이스의 **테이블이 잘 만들어졌는지 평가하고 잘 만들지 못한 테이블을 고쳐나가는 과정,** 테이블을 **정규형(normal form)이라고 불리는 형태에 부합하게** 만들어나감

순서에 따라 규칙이 누적됨

![Untitled](/Users/honeysmacbook/Desktop/Screenshot 2022-01-13 at 21.29.27.png)

- `1NF`
- `2NF`
- `3NF`
- ...

더 많은 정규형이 있지만 제 3정규형에 부합하기만 해도 대부분 좋은 데이터 베이스이다.

> 정규화가 잘 지켜질 경우 데이터베이스에서 삽입, 업데이트, 삭제 이상을 없앨 수 있고 새로운 종류의 데이터를 추가할 때 테이블 구조 수정을 많이 하지 않아도 되고 데이터베이스 구조를 단순화해서 사용자가 더 쉽게 이해할 수 있다. 정규화는 데이터 모델을 만들고 **데이터베이스에 구현하기 전에 적용하면 좋다**. 이미 구현된 데이터베이스에 정규화를 구현할 수도 있지만 데이터베이스 수정 작업이 어렵기 때문에 미리 적용하는 것이 좋다.

### 📕 1NF (제 1정규형)

제 1정규형에 부합하기 위해 테이블 안 모든 로우의 모든 컬럼 값들은 **나눌 수 없는 단일 값**이어야 한다.

예) 한 컬럼에 여러 개의 값이 있으면 안된다. 한 user가 여러 개의 전화번호를 가진 경우 한 컬럼에 여러 개의 값이 있으면 안된다. 여러 개의 전화번호를 관리해야 하는 경우 한 테이블에 여러 개의 컬럼을 만드는 것보다 전화번호를 위한 테이블을 하나 만들어서 분리하는 것이 좋은 방법이다 같은 내용을 저장하는 컬럼이 여러 개가 있는 경우 1. NULL이 많이 생길 수 있고 2. 컬럼을 몇 개 만들어야 하는지 애매하고 3. 조회가 비효율적이다

**1NF : 확대 해석**

1NF를 단순하게 의미 그대로 해석한다면 컬럼을 여러 개로 나누는 것도 테이블이 1NF를 지키게 바꾸는 게 맞다. 하지만 어떤 데이터베이스 학자들은 “나눌 수 없는 단일 값”을 테이블 안에 있는 모든 값들이 **무조건 하나의 값만 가져야 된다**는 의미로 해석한다

1NF를 지키기 위해 단순히 테이블의 컬럼을 늘리게 된다면 구조적으로 NULL이 많이 생기게 되는 문제가 발생하는데 그렇게 되면 값이 없는 컬럼들이 생기면서 **구조적으로 NULL이 발생해 1NF에 부합하지 않는다는 주장이다**.

**컬럼에 서로 같은 여러 값이 저장되어 있을 때** 1NF를 어떻게 해석하는지와 상관 없이 단순히 같은 데이터를 저장하는 컬럼을 늘려서 1NF를 지키려고 하는 방법은 좋지 않은 모델링이다.

**컬럼에 서로 같은 다른 값이 저장되어 있을 때**

흔히 사용하는 예 중에도 엄밀히 따지면 1NF를 위반하는 경우가 있다. 이름은 나눌 수 없는 단일 값이 아니다. 성과 이름으로 구성되기 때문이다. 이런 경우에는 그냥 컬럼을 여러 개로 나눠서 퍼스트, 미들, 라스트 네임 커럼을 만들어주면 된다.



**나눌 수 없는 단일 값 기준**

길이가 2 이상인 모든 문자열은 더 작은 문자로 나눌 수 있고 소수도 소수 부분과 정수 부분으로 나눌 수 있다. 이런 문제점 때문에 “나눌 수 없는 단일 값"이라는 표현 자체가 불완전하다는 의견도 많다. 그 의미가 항상 명확하진 않을 수 있어도 **컬럼 값을 사용할 때 온전히 그 단위 자체로 사용하는지, 저장하는 값들을 일부분만 사용할 수도 있는지를 판단하고 그걸 바탕으로 모델링하면 된다.**



📝 **핵심**

1NF를 지키지 않는 경우는 크게 두 가지

1. 한 컬럼에 

   같은 종류의 값

   을 여러 개 저장하고 있을 때

   - 해당 컬럼을 **하나의 테이블로 분리**해서 모델링한다.

2. 한 컬럼에 

   서로 다른 종류의 값

   을 여러 개 저장하고 있을 때

   - **한 컬럼을 여러 개로 분리**해서 모델링한다.

### 📕 2NF

> 2NF (제 2정규형)에 부합하기 위해서는 우선 1NF에 부합해야 한다. 추가적으로 **테이블에 candidate key의 일부분에 대해서만 함수 종속성이 있는 non-prime attribute가 없어야 한다.** 제 2정규형을 지키지 않는 테이블을 고치기 위해서는 attribute들끼리 분리해서 테이블을 여러 개로 나눠주면 된다.

### 📕 3NF

> 제 2정규형에 부합해야 한다. (나눌 수 없는 단일값이면서 candidate key의 일부분에 대해서만 함수 종속성이 있는 non-prime attribute가 없다.) 추가적으로 **테이블 안에 있는 모든 attribute들은 오직 primary key에 대해서만 함수 종속성이 있다**. → 테이블의 모든 attribute는 직접적으로 테이블의 Entity에 대한 내용이어야만 한다.



## 📌 3. 함수 종속성 (Functional Dependency)

x의 값에 따라서 y의 값이 결정될 때 **y는 x에 함수 종속성이 있다**고 한다.

$$ x \rightarrow y $$

예) 값이 중복되지 않는 컬럼 (이메일)이 있는 경우 해당 컬럼의 값만 알면 나머지 값들도 알 수 있다. 이런 경우 name, age컬럼은 email컬럼에 함수 종속성이 있다고 표현한다. 반대로 나이를 안다고 해도 그 사람의 나머지 정보는 알 수 없다(중복이 있기 때문에) 그런 경우에는 함수 종속성이 없다. $\{ name, age \} \rightarrow email$

### 📕 이행성

**이행성** : 하나 이상의 attribute를 건너 함수 종속성이 있는 경우

product → brand → brand_country

브랜드의 국적은 제품에 대한 이행적 함수 종속성이 있다.



## 📌 4. Candidate Key

**Candidate Key** : **하나의 로우를 특정 지을 수 있는 attribute들의 최소 집합**

예) review테이블에 id, user_id, product_id, score, description 컬럼이 있는 경우 user_id와 product_id를 알면 어떤 리뷰인지 정확히 특정지을 수 있다. id만알아도 한 로우를 특정지을 수 있다. 캔디더트 키에 포함된 모든 attribute를 `prime attribute`라고 한다. `non-prime attribute`는 캔디더트 키에 포함되지 않는 모든 attribute를 의미한다.



## 📌 5. 정규화 정리

![Screenshot 2022-01-25 at 21.33.06.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8ed3617c-d704-424e-a480-1f2081631d01/Screenshot_2022-01-25_at_21.33.06.png)

### 📕 1NF

테이블이 1NF에 부합하기 위해서는 테이블 안에 있는 모든 값이 **나눌 수 없는 단일 값** 이어야 한다. keywords 컬럼에는 여러 개의 키워드들이 저장되어 있어 1NF에 부합하지 않는다. 그래서 1NF에 부합하게 만들기 위해서는 keywords 컬럼을 테이블로 분리해야 한다.

![Screenshot 2022-01-25 at 21.36.17.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a394702-e350-4b99-8711-00465a26790e/Screenshot_2022-01-25_at_21.36.17.png)

그리고 두 테이블 사이의 관계를 모델링 해야 한다. 비즈니스 룰을 이용해 관계의 카디널리티를 파악한다. 하나의 제품은 여러 개의 키워드를 가질 수 있고 하나의 키워드는 여러 제품에서 사용될 수 있기 때문에 두 테이블 사이에는 M:N(다대다) 관계가 있다. 연결 테이블을 추가하면 아래와 같은 형태가 된다.

![Screenshot 2022-01-25 at 21.38.10.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ed03c068-55e8-464a-8137-888216f24670/Screenshot_2022-01-25_at_21.38.10.png)

1NF에 부합하지 않는 테이블 하나를 1NF에 부합하는 테이블 세 개로 나눴다.

### 📕 2NF

이제는 2NF에 부합하게 정규화할 차례이다. 현재 테이블은 1NF에 부합하고 있기 때문에  2NF에 부합하기 위해서는 candidate key의 일부분에만 의존하는 non-prime attribute를 없애야 한다.

**candidate key 찾기**

이걸 알아내기 위해 테이블의 candidate key와 non-prime attribute들을 파악해야 한다. id는 attribute 하나만으로 모든 상품을 특정지을 수 있기 때문에(일부분이란 개념이 없기 때문에) 생각하지 않고 여러 attribute의 조합으로 만들어지는 candidate key에 대해서만 생각한다.

테이블에서 상품이름 name, 브랜드 이름 brand, 크기 size 이 세 attribute가 있으면 하나의 상품을 특정지을 수 있다. {name, brand, size}가 하나의 candidate key가 된다.

그리고 candidate key에 포함되지 않는 다른 모든 attribute인 ({brand_country, in_stock, price, designer, designer_country}) 모두 non-prime attribute이다.

**non-prime attribute들의 함수 종속성 찾기**

테이블이 2NF에 부합하기 위해서는 각각 name, brand, size, attribute들 각각, 또는 여기서 두 개의 attribute의 조합에 대한 함수 종속성이 있는 non-prime attribute가 있으면 안된다.

각 non-prime attribute의 함수 종속성은 아래로 정리된다.

*brand* → *brand*_*country*

{name, brand} → {price, designer, designer_country}

{name, brand, size} → {in_stock}

브랜드 국가는 브랜드에 대해서, 가격, 디자이너, 디자이너 국적은 제품 이름과 브랜드에 대해, 재고는 제품 이름, 브랜드, 크기에 대해 함수 종속성이 있다.

**테이블 분리하기**

2NF에 부합하게 만들기 위해서는 product테이블을 모든 non-prime attribute가 candidate key의 전체에만 함수 종속성이 있는 세 개의 테이블로 분리해야 한다.

![Screenshot 2022-01-25 at 21.50.52.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/40821c7b-f220-441c-a61f-e4bafa262c02/Screenshot_2022-01-25_at_21.50.52.png)

그리고 이 테이블들 사이 관계를 모델링해야 한다. 비즈니스 룰을 사용해 관계의 카디널리티를 파악한다.

콜라보 제품은 고려하지 않고 상품은 딱 하나의 브랜드만 가질 수 있다. 반면 브랜드는 수많은 상품을 가질 수 있다.

brand와 product 사이에는 1:N 관계가 있다. 다수에 해당하는 product 테이블에 foreign key를 넣어줘서 관계를 모델링한다.

![Screenshot 2022-01-25 at 21.55.32.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/737bea3d-0844-41f7-9549-57a902df34e6/Screenshot_2022-01-25_at_21.55.32.png)

2NF에 부합하지 않는 하나의  테이블을 2NF에 부합하는 세 개의 테이블로 나눴다.

### 📕 3NF

이제는 테이블이 3NF에 부합하게 정규화해야한다. 이미 2NF에 부합하는 테이블이 3NF에 부합하기 위해서는 테이블 안 모든 attribute는 primary key에 대해 직접적인 함수 종속성이 있어야 한다. 이행적 함수 종속성도 있으면 안된다.

**이행적 함수 종속 파악**

테이블을 살펴보면 name, brand_id, price, designer 모두 한 상품에 대한 내용이다. 직접적으로 id에 대한 함수 종속성이 있다. 하지만 디자이너 국적은 직접적으로 어떤 상품인지가 아니라 어떤 디자이너 인지에 따라 결정되는 값이다. 함수종속성이 이행적이다. id → designer → designer_nationality 3NF를 어기고 있다.

**테이블 분리**

이걸 해결하기 위해 designer에 대한 컬럼들을 따로 테이블로 분리해야 한다.

![Screenshot 2022-02-03 at 20.51.32.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0abcb73e-33d4-4ea2-8626-8b74b790314b/Screenshot_2022-02-03_at_20.51.32.png)

그리고 이 테이블 사이 관계를 모델링한다. 이를 위해 비즈니스 룰을 사용해 관계의 카디널리티를 파악한다. 하나의 상품에는 하나의 디자이너만 있을 수 있고 한 명의 디자이너는 여러 제품을 디자인할 수 있기 때문에 1:N 관계이다. 다수에 해당하는 상품 테이블에 foreign key를 넣어줘서 관계를 모델링한다.

![Screenshot 2022-02-03 at 20.52.29.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a2409a46-364b-4cad-8e3e-4026725046ab/Screenshot_2022-02-03_at_20.52.29.png)

### 💡 정리

정규화되지 않은 하나의 테이블을 3NF에 부합하는 6개의 테이블로 나눴다. 3NF까지 정규화를 하고나면 중복되는 데이터 등 모델링 실수로 생기는 데이터베이스 이상 현상을 웬만해서 다 예방할 수 있다. ***일반적으로 3NF에 부합하는 데이터베이스를 “정규화된 데이터베이스"라고 한다***.

![Screenshot 2022-02-03 at 21.10.33.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c35f290d-6b59-40b4-9384-9a405cab4d5f/Screenshot_2022-02-03_at_21.10.33.png)

![Screenshot 2022-02-03 at 21.11.13.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3bdfc3a6-7898-425e-9043-1f3b6ac7abb1/Screenshot_2022-02-03_at_21.11.13.png)

## 📌 6. 비정규화

<aside> 💡 **비정규화** : 정규형에 부합하는 테이블을 정규형을 지키지 않게 바꾸는 것 비정규화를 하는 이유 : 성능 개선을 위해

</aside>

정규형을 지키기 위한 가장 기본적인 해법은 하나의 테이블을 여러 개로 나누는 것, 그렇기 때문에 데이터베이스에서 원하는 데이터를 찾을 때는 조인(join)을 사용해서 다양한 테이블들에 있는 데이터를 합쳐야 하는 경우가 많다. ***정규화로 인해서 데이터가 이곳저곳 많이 퍼져있으면 퍼져있는 데이터를 다시 모을 때 속도가 느려질 수 있다. 비정규화를 하면 이런 정보들은 한 테이블에 저장할 수 있기 때문에 조금 더 빠르게 조회를 할 수 있다.***
