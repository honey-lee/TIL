## 📌 1. 데이터베이스 이상 현상

**데이터 이상 현상(anomaly) :** 데이터베이스에서 삽입, 업데이트, 삭제를 제대로 할 수 없게 되는 경우, 데이터 모델링을 제대로 하지 않았기 때문에 발생

1. **삽입 이상** : 새로운 데이터를 자연스럽게 저장할 수 없는 경우
2. **업데이트 이상** : 데이터를 업데이트했을 때 정확성을 지키기 어려워지는 경우
3. **삭제 이상** : 원하는 데이터만 자연스럽게 삭제할 수 없는 경우

## 📌 2. 정규화 (Normalization)

**정규화** : 데이터베이스의 **테이블이 잘 만들어졌는지 평가하고 잘 만들지 못한 테이블을 고쳐나가는 과정,** 테이블을 **정규형(normal form)이라고 불리는 형태에 부합하게** 만들어나감

순서에 따라 규칙이 누적됨

![Untitled](/Users/honeysmacbook/Desktop/Screenshot 2022-01-13 at 21.29.27.png)

- `1NF`
- `2NF`
- `3NF`
- ...

더 많은 정규형이 있지만 제 3정규형에 부합하기만 해도 대부분 좋은 데이터 베이스이다.

> 정규화가 잘 지켜질 경우 데이터베이스에서 삽입, 업데이트, 삭제 이상을 없앨 수 있고 새로운 종류의 데이터를 추가할 때 테이블 구조 수정을 많이 하지 않아도 되고 데이터베이스 구조를 단순화해서 사용자가 더 쉽게 이해할 수 있다. 정규화는 데이터 모델을 만들고 **데이터베이스에 구현하기 전에 적용하면 좋다**. 이미 구현된 데이터베이스에 정규화를 구현할 수도 있지만 데이터베이스 수정 작업이 어렵기 때문에 미리 적용하는 것이 좋다.

### 📕 1NF (제 1정규형)

제 1정규형에 부합하기 위해 테이블 안 모든 로우의 모든 컬럼 값들은 **나눌 수 없는 단일 값**이어야 한다.

예) 한 컬럼에 여러 개의 값이 있으면 안된다. 한 user가 여러 개의 전화번호를 가진 경우 한 컬럼에 여러 개의 값이 있으면 안된다. 여러 개의 전화번호를 관리해야 하는 경우 한 테이블에 여러 개의 컬럼을 만드는 것보다 전화번호를 위한 테이블을 하나 만들어서 분리하는 것이 좋은 방법이다 같은 내용을 저장하는 컬럼이 여러 개가 있는 경우 1. NULL이 많이 생길 수 있고 2. 컬럼을 몇 개 만들어야 하는지 애매하고 3. 조회가 비효율적이다

**1NF : 확대 해석**

1NF를 단순하게 의미 그대로 해석한다면 컬럼을 여러 개로 나누는 것도 테이블이 1NF를 지키게 바꾸는 게 맞다. 하지만 어떤 데이터베이스 학자들은 “나눌 수 없는 단일 값”을 테이블 안에 있는 모든 값들이 **무조건 하나의 값만 가져야 된다**는 의미로 해석한다

1NF를 지키기 위해 단순히 테이블의 컬럼을 늘리게 된다면 구조적으로 NULL이 많이 생기게 되는 문제가 발생하는데 그렇게 되면 값이 없는 컬럼들이 생기면서 **구조적으로 NULL이 발생해 1NF에 부합하지 않는다는 주장이다**.

**컬럼에 서로 같은 여러 값이 저장되어 있을 때** 1NF를 어떻게 해석하는지와 상관 없이 단순히 같은 데이터를 저장하는 컬럼을 늘려서 1NF를 지키려고 하는 방법은 좋지 않은 모델링이다.

**컬럼에 서로 같은 다른 값이 저장되어 있을 때**

흔히 사용하는 예 중에도 엄밀히 따지면 1NF를 위반하는 경우가 있다. 이름은 나눌 수 없는 단일 값이 아니다. 성과 이름으로 구성되기 때문이다. 이런 경우에는 그냥 컬럼을 여러 개로 나눠서 퍼스트, 미들, 라스트 네임 커럼을 만들어주면 된다.



**나눌 수 없는 단일 값 기준**

길이가 2 이상인 모든 문자열은 더 작은 문자로 나눌 수 있고 소수도 소수 부분과 정수 부분으로 나눌 수 있다. 이런 문제점 때문에 “나눌 수 없는 단일 값"이라는 표현 자체가 불완전하다는 의견도 많다. 그 의미가 항상 명확하진 않을 수 있어도 **컬럼 값을 사용할 때 온전히 그 단위 자체로 사용하는지, 저장하는 값들을 일부분만 사용할 수도 있는지를 판단하고 그걸 바탕으로 모델링하면 된다.**



📝 **핵심**

1NF를 지키지 않는 경우는 크게 두 가지

1. 한 컬럼에 

   같은 종류의 값

   을 여러 개 저장하고 있을 때

   - 해당 컬럼을 **하나의 테이블로 분리**해서 모델링한다.

2. 한 컬럼에 

   서로 다른 종류의 값

   을 여러 개 저장하고 있을 때

   - **한 컬럼을 여러 개로 분리**해서 모델링한다.



## 📌 3. 함수 종속성 (Functional Dependency)

x의 값에 따라서 y의 값이 결정될 때 **y는 x에 함수 종속성이 있다**고 한다.

$$ x \rightarrow y $$

예) 값이 중복되지 않는 컬럼 (이메일)이 있는 경우 해당 컬럼의 값만 알면 나머지 값들도 알 수 있다. 이런 경우 name, age컬럼은 email컬럼에 함수 종속성이 있다고 표현한다. 반대로 나이를 안다고 해도 그 사람의 나머지 정보는 알 수 없다(중복이 있기 때문에) 그런 경우에는 함수 종속성이 없다. $\{ name, age \} \rightarrow email$

### 📕 이행성

**이행성** : 하나 이상의 attribute를 건너 함수 종속성이 있는 경우

product → brand → brand_country

브랜드의 국적은 제품에 대한 이행적 함수 종속성이 있다.



## 📌 4. Candidate Key

**Candidate Key** : **하나의 로우를 특정 지을 수 있는 attribute들의 최소 집합**

예) review테이블에 id, user_id, product_id, score, description 컬럼이 있는 경우 user_id와 product_id를 알면 어떤 리뷰인지 정확히 특정지을 수 있다. id만알아도 한 로우를 특정지을 수 있다. 캔디더트 키에 포함된 모든 attribute를 `prime attribute`라고 한다. `non-prime attribute`는 캔디더트 키에 포함되지 않는 모든 attribute를 의미한다.
