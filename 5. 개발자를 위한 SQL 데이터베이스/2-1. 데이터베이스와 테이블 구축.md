# 데이터베이스와 테이블 구축

## 📌 1. 데이터베이스 생성하기

- 같은 이름의 데이터베이스를 또 생성하면 에러 발생 → `IF NOT EXISTS` 구문을 사용하면 에러 발생을 방지할 수 있음

```sql
-- CREATE DATABASE 데이터베이스의 이름
CREATE DATABASE course_rating;

-- 존재하지 않을 경우 해당 이름의 데이터베이스 생성
CREATE DATABASE IF NOT EXISTS course_rating;
```

### ❗️사용할 데이터베이스 지정하기

- 우선 사용할 데이터베이스 지정하기 (어떤 데이터베이스에 테이블을 추가하는 건지 명확하게 해주기 위해)

```sql
USE course_rating;
```

- `USE` 명령어 사용 후에는 그 데이터베이스를 *작업 중인 데이터베이스*로 인식하게 되고 이후에는 그 데이터베이스 이름을 적어주지 않아도 된다.
    - 현재 작업 중인 데이터베이스 안의 테이블을 조회할 경우 → `SELECT * FROM animal` : 테이블 이름 바로 적기 가능
    - 현재 작업중이지 않은 데이터베이스 안의 테이블을 조회할 경우 → `SELECT * FROM B.banana` : 데이터베이스의 이름을 적어주어야 함

## 📌 2. 테이블 추가하기

- 테이블의 이름 지정
- 각 컬럼의 데이터 타입과 특성을 지정
    - NULL : 해당 컬럼은 null값 허용, 쓰지 않아도 기본으로 NULL속성이 지정됨
    - PK로 지정할 컬럼에 `PRIMARY KEY`라고 써줘도 동일한 기능을 함

```sql
CREATE TABLE `course_rating`.`student` (
	`id` INT NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(20) NULL,
	`student_number` INT NULL,
	`major` VARCHAR(15) NULL,
	`email` VARCHAR(50) NULL, 
	`phone` VARCHAR(15) NULL,
	`admission_date` DATE NULL,
	PRIMARY KEY (`id`));
```

❗️DMBS에서 백틱은 식별자임을 나타내는 기호이다. 백틱을 써주지 않아도 SQL문은 정상적으로 잘 실행된다. 하지만 백틱을 써줌으로서 어느 단어가 사용자가 직접 이름을 지은 부분인지 명확히 나타낼 수 있고 이미 SQL문법에 정해진 키워드(SELECT 등) 로 이름을 짓고 싶을 때는 백틱문을 사용해주는 것이 필수이다.

## 📌 3. 컬럼의 데이터 타입

- 테이블을 생성할 때 각 컬럼마다 저장될 값에 알맞은 **데이터 타입을 설정** 하는데 적절한 데이터 타입을 잘 설정하는 일은 아주 중요 → 저장 용량을 효율적으로 활용할 수 있고 나중에 row 수가 많아졌을 때 성능에 영향을 미침

**일반적으로 많이 쓰이는 데이터 타입 : 숫자형, 날짜 및 시간, 문자열**

### 📝 1. Numeric types (숫자형 타입)

1. 정수형 타입
    1. `TINYINT` : 작은 범위의 정수들을 저장할 때 쓰는 데이터 타입, TINYTINT에서 INT는 Integer의 줄임말로 **최소 -128 ~ 최대 127까지의 정수를 저장할 수 있는 타입**이다. `SIGNED`는 양수, 0, 음수를 나타내고 `UNSIGNED`는 0과 양수를 나타낸다.
        1. `TINYINT SIGNED` : -128 ~ 127
        2. `TINYINT UNSIGNED` : 0 ~ 255
    2. `SMALLINT` : TINYINT보다 좀 더 큰 범위의 정수를 나타낼 때 쓰는 데이터 타입 
        1. `SMALLINT SIGNED` : -32768 ~ 32767
        2. `SMALLINT UNSIGNED` : 0 ~ 65535
    3. `MEDIUMINT` : 더 넓은 범위를 나타내는 데이터 타입 
        1. `INT SIGNED` : -2147483648 ~ 2147483647
        2. `INT UNSIGNED` : 0 ~ 4294967295
    4. `BIGINT` : 아주 큰 범위의 정수를 저장하는 데이터 타입
        1. `BIGINT SIGNED` : -9223372036854775808 ~ 9223372036854775807
        2. `BIGINT UNSIGNED` : 0 ~ 18446744073709551615
2. 실수형 타입 : 얼마나 넓은 범위의 수를 나타낼 수 있는지 뿐만 아니라 소수점 뒤에 얼마나 많은 갯수의 자리수가 존재할 수 있는지 (하나의 값을 얼마나 정밀하게 표현할 수 있는지) 다르다
    1. `DECIMAL` : 일반적으로 자주 쓰이는 실수형 타입 중 하나로 보통 `DECIMAL(M, D)` 의 형식으로 나타낸다. 여기서 M은 최대로 쓸 수 있는 전체 숫자의 자리수이고 D는 최대로 쓸 수 있는 소수점 뒤에 있는 자리의 수를 의미한다 
    2. `FLOAT` : 3.402823466E+38 ~ -1.175494351E-38, 0, 1.175494351E-38 ~ 3.402823466E+38 범위의 실수들을 나타낼 수 있는 데이터 타입
    3. `DOUBLE` : 1.7976931348623157E+308 ~ -2.2250738585072014E-308, 0, 2.2250738585072014E-308 ~ 1.7976931348623157E+308 범위의 실수들을 나타낼 수 있는 데이터 타입으로 FLOAT에 비해 더 넓은 범위의 수를 나타낼 수 있을 뿐 아니라 그 정밀도 또한 더 높은 타입이다. (소수점 뒤에 최대로 허용 가능한 자릿수가 더 많음)
    

### 📝 2. Date and Time types (날짜 및 시간 타입)

1. `DATE` :  날짜를 저장하는 데이터 타입, 연, 월, 일 순으로 값을 나타냄
2. `DATETIME` : 날짜와 시간을 저장하는 데이터 타입, 연, 월, 일, 시, 분, 초를 나타냄
3. `TIMESTAMP` : 날짜와 시간을 저장하는 데이터 타입, 타임 존 정보도 함께 저장한다
4. `TIME` : 시간을 나타내는 데이터 타입, 시:분:초를 나타냄

### 📝 3. String types (문자열 타입)

1. `CHAR` : 문자열을 나타내는 기본 타입으로 Character의 줄임말이다. 
2. `VARCHAR` : 문자열의 최대 길이를 지정할 수 있는 문자열 타입으로 `CHAR`보다 허용되는 최대 저장 길이가 더 크다. 또 하나의 차이점은 **가변 길이 타입**이라는 점이다. `CHAR(10)`경우 어떤 길이의 문자열이 저장되더라도 그 값이항상 10만큼의 저장 용량을 차지한다. 하지만 `VARCHAR(10)`의 경우 **저장 용량이 설정된 최대 길이에 맞게 고정되는게 아니라 실제 저장된 값에 맞게 최적화** 된다. 따라서 값의 길이가 크게 변하지 않을 컬럼에는 CHAR 타입, 길이가 들쑥날쑥한 컬럼에는 VARCHAR타입을 쓰는게 좋다
3. `TEXT` : 문자열을 저장하는 데이터 타입으로 최대 65535자 까지 저장할 수 있다. VARCHAR 타입과 TEXT 계열의 타입은 내부 구현에서 일부 차이가 있다 

## 📌 4. 테이블에 row 추가하기

- `INSERT INTO` 문을 사용해서 새로운 row 추가 가능
- auto_increment 속성을 가진 컬럼에는 값을 넣지 않아도 자동으로 들어감

```sql
INSERT INTO student 
	(id, name, student_number, major, email, phone, admission_date)
	VALUES (1, '손오공', '20211108', 'computer science', 'aaa@a.com', '010-1234-5678', '2021-11-07');

-- 컬럼 이름은 생략 가능 (모든 컬럼에 값이 있을 경우)
INSERT INTO student 
	VALUES (1, '손오공', '20211108', 'computer science', 'aaa@a.com', '010-1234-5678', '2021-11-07');

-- 특정 컬럼에만 값을 준 채로 값 넣기
INSERT INTO student 
	(id, name, student_number, major, admission_date)
	VALUES (1, '손오공', '20211108', 'computer science', '2021-11-07');
```

## 📌 5. 테이블의 row 갱신하기

- `UPDATE` 문을 사용해서 기존의 정보를 갱신 가능
- 갱신 시는 where절이 아주 중요하다 → where절이 없으면 특정 row가 아닌 모든 row를 갱신해버리기 때문에 어떤 row를 갱신할지 지정해야한다 ❗️

```sql
-- 특정 학생의 학과와 이름 갱신하기 
UPDATE student 
	SET major = '멀티미디어학과', name = '차소원' 
	WHERE id = '2';
```

### 📝  컬럼의 기존 값을 기준으로 갱신하기

- 학생들의 점수가 담긴 테이블에 모든 점수를 3점씩 올려주어야 하는 상황일 경우

```sql
UPDATE final_exam_result SET score = score + 3;
```

## 📌 6. 테이블의 row 삭제하기

- `DELETE`문을 사용해 특정 정보 삭제하기
- 삭제 시도 마찬가지로 where절이 아주 중요

```sql
DELETE FROM student WHERE id = 4;
```



### 물리 삭제 vs 논리 삭제

우리가 배웠던 것처럼, 데이터를 삭제해야할 때 그냥 row를 바로 삭제해버리는 것을 ‘물리 삭제’라고 합니다. 

반면에 ‘논리 삭제’는 삭제해야할 row를 삭제하지 않고, **‘삭제 여부’를 나타내는 별도의 컬럼을 두고, 거기에 ‘삭제되었음’을 나타내는 값을 넣는 것**을 말하죠.

처럼 UPDATE 문을 써야 하는거죠. 

결국 '물리 삭제'와 '논리 삭제'는 정책상의 차이를 나타내는 분류라고 할 수 있습니다.

그렇다면 이렇게 논리 삭제를 하는 이유는 무엇일까요? 다양한 이유가 있을 수 있습니다. 

위의 예시와 같은 경우를 보자면, 비록 사용자가 주문을 취소했다고 해도 해당 주문은 사용자의 취향, 기호 등이 반영된 소중한 데이터입니다. 즉, 기업 입장에서는 고객 분석을 위해 필요한 소중한 데이터라는 거죠. 그래서 설사 소비자는 주문을 취소(삭제)했다고 하더라도 기업은 해당 데이터를 계속 보관하고 있는 겁니다. 

뿐만 아니라 이런 논리 삭제는 향후에 범죄 수사 등에 도움이 될 수도 있습니다. 예를 들어, 어떤 사람이 SNS 사이트에 가입해서 게시판에서 남을 비방하는 유언비어 게시물을 여러 개 남기는 등의 행위를 하고 바로 해당 사이트를 탈퇴해버렸다고 합시다. 그런데 만약 이때 해당 회원 정보를 '물리 삭제’ 해버리면 이제 그 행위를 어떤 계정이 했는지 찾을 수 없게 됩니다. 하지만 논리 삭제를 했다면, 관련 계정을 바로 찾을 수 있겠죠? 

하지만 이런 논리 삭제도 약간의 단점은 있는데요. 

먼저, 나중에 삭제되지 않고 유효한 row들만 조회해야할 때는 

처럼 WHERE 절에 별도의 조건을 추가해줘야해서 번거롭다는 단점이 있습니다.

그리고 실제로 row를 삭제하는 것이 아니기 때문에 아무리 삭제를 해도 데이터베이스 내의 저장용량은 줄어들지 않는다는 단점도 있습니다. 

이런 단점을 보완하기 위해 기본 정책은 논리 삭제로 두되, 

- 이미 데이터 분석에 활용되었거나
- 고객이 동의한 데이터 보유기간이 지난 row들은

정기적으로 물리 삭제하는 방법을 활용하기도 합니다. 

나중에 실무에서 여러분의 회사에서는 어떤 식으로 삭제 정책을 운영하고 있는지 한번 살펴보세요. 