# 완전 검색 & 그리디

> - 반복 & 재귀
> - 완전 검색 기법
> - 조합적 문제 
> - 탐욕 알고리즘



## 반복과 재귀

- 반복 구조
  - 초기화 : 조건 검사에 사용할 변수의 초기값 설정
  - 조건 검사 (check control expression)
  - 반복할 명령문 실행 (action)
  - 업데이트 (loop update)



- 반복을 이용한 **선택정렬**

  ```python
  def SelectionSort(A):
      
      n = len(A)
      
      for i in range(0, n-1):
          min = i
          for j in range(i+1, n):
              if A[j] < A[min]:
                  min = j
              A[min], A[i] = A[i], A[min]
  ```

  

- 재귀적 알고리즘

  - 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수 

  - 기본 부분과 유도 부분으로 구성 

  - 반복 구조에 비해 간결하고 이해하기 쉽다 

  - 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생한다. 

  - 팩토리얼 재귀함수

    ```python
    fact(n)
    	# 기본 부분
    	if n <= 1:
            return 1
        # 유도 부분
        else:
            return n * fact(n-1)
    ```

    

|                    |                  재귀                   |        반복        |
| :----------------: | :-------------------------------------: | :----------------: |
|      **종료**      | 재귀 함수 호출이 종료된느 베이스 케이스 | 반복문의 종료 조건 |
|   **수행 시간**    |               상대적 느림               |        빠름        |
|  **메모리 공간**   |            상대적 많이 사용             |     적게 사용      |
| **소스 코드길이**  |                짧고 간결                |        길다        |
| **소스 코드 형태** |                선택 구조                |     반복 구조      |
|  **무한 반복 시**  |             스택 오버플로우             |   CPU 반복 점유    |



## 고지식한 방법 (Brute Force)

- Brute-force 탐색 (sequential search) : 자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행한다.

  -  모든 경우의 수를 생성하고 테스트하기 때문에 속도는 비교적 오래 걸리나 답을 찾아내지 못할 확률이 적음

  ```python
  SequentialSearch(A[0 .. n], k)
  
  	A[n] = k
      i = 0
      
      while A[i] != k:
          i += 1
          
      if i < n: return i
      else: return -1
  ```

  

## 순열과 조합

- 조합 : 서로 다른 n개의 원소 중 r개를 순서없이 골라낸 것 

$$
nCr = {n! \over (n-r)!r!}
$$

$$
nCr = {n-1}C_{r-1} + {n-1}C_{r}
$$

- 예시 문제) M개에서 3개를 고르는 경우 ( 5 <= M <= 10) 아래의 범위에서 3개 선택 가능 

  - i : 0 -> M-3
  - j : i+1 -> M-2
  - k : j+1 -> M-1

  ```PYTHON
  M = 5
  a = [1, 2, 3, 4, 5]
  
  for i in range(0, M-3+1):
      for j in range(i+1, M-2+1):
          for k in range(j+1, M-3+1):
              print(a[i], a[j], a[k])
              
  # 123 124 125 234 235 245 345
  ```

  ```python
  n = 5
  r = 3
  A = [1, 2, 3, 4, 5]
  c = [0] * r
  
  # n개 중에 r개 고르기 
  def f(i, j, n, r): 
      if i == r:
          print(c)
      else:
          # i를 이용해 선택구간을 하나씩 늘려간다 
          for k in range(j, n-r+i+1):
              c[i] = A[k]
              f(i+1, k+1, n, r)
  ```



## 부분집합

- 생성 방법

  - 바이너리 카운팅 (Binary Counting)

    - 원소 수에 해당하는 N개의 비트열을 이용한다
    - n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다

    | 10진수 | 이진수 | {A, B, C, D} |
    | :----: | :----: | :----------: |
    |   0    |  0000  |      {}      |
    |   1    |  0001  |     {A}      |
    |   2    |  0010  |     {B}      |
    |   3    |  0011  |    {B, A}    |
    |   4    |  0100  |     {C}      |
    |   5    |  0101  |    {C, A}    |
    |   6    |  0110  |    {C, B}    |
    |  ...   |  ...   |     ...      |
    |   15   |  1111  | {D, C, B, A} |

    ```python
    # 바이너리 카운팅을 통한 부분집합 생성
    
    arr = [1, 3, 4, 5, 6, 7]
    n = len(arr)
    
    for i in range(0, (1<<n)): # 1<<n : 부분집합의 갯수
        for j in range(0, n):  # 원소의 수만큼 비트를 출력
            if i & (1<<j):     # i의 j번째 비트가 1이면 j번째 원소 출력
                print('%d'%arr[j], end=' ')
            print()
    ```

    ```python
    # 합이 0인 부분집합 구하기 
    
    arr = [-1, -3, 1, 3, 4, 5, 6, 7]
    n = len(arr)
    
    for i in range(1<<8):
        s = 0
        for j in range(8):
            if i & (1<<j):
                s += arr[j]
        if s == 0:
            for j in range(10):
                if i & (1<<j):
                    print(A[j], end=' ')
                print()
    ```



## 탐욕 알고리즘

- 최적해를 구하는데 사용되는 근시안적인 방법
- 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다 -> 지역적으로는 최적이지만 결론적으로는 그것이 최적이라는 보장이 없다

- 예시문제) Knapsack : 한정된 무게 내에 최대한 많은 물건 담기

  - 완전 검색으로 물건들의 집합 S에 대한 모든 부분 집합을 구한다
  - 부분 집합의 총 무게가 W를 초과하는 집합들은 버리고 나머지 집합에서 총 값이 큰 것을 고른다 
  - => 결론적으로 탐욕 알고리즘이 최적이라는 보장이 없다는 것을 알 수 있다.

- 예시문제) 활동 선택 문제

  - 종료 시간이 빠른 순서로 활동들 정렬
  - 첫번째 활동 A1 선택
  - 선택한 활동의 종료시간보다 빠른 시작 시간을 가지는 활동을 모두 제거
  - 남은 활동들에 대해 앞의 과정 반복

  ```python
  #A : 활동들의 집합, S : 선택된 활동들의 집합
  #Si : 시작시간, Fi : 종료 시간, 1 <= i <= n
          
  Sort A by finish time
  S <- {A1}
  j <- 1 # j : 가장 최근에 선택한 활동 
  for i in range(2, n):
      if si >= fj:
          S <- S U {Ai} # 남은 것 중에서
          j <- i
  ```

  ```python
  # 재귀
  
  RecursiveSelection(i, j):
      m = i + 1
      
      while m < j and sm < fi: # 종료 시간이 가장 빠른 활동 선택 
          m += 1
          
      if m < j: return {am} U RecursiveSelection(m, j) #종료 시간 이후에 종료하는 활동들과 합집합 
      else: return {} #공집합
  ```

  

- 탐욕 알고리즘의 필수 요소 
  - 탐욕적 선택 속성
  - 최적 부분 구조
  - **[원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해]** 임을 증명하라 

- 탐욕 알고리즘 vs 동적 계획법

| 탐욕 알고리즘                                                | DP (동적 계획법)                                  |
| ------------------------------------------------------------ | ------------------------------------------------- |
| 매 단계에서 가장 좋게 보이는 것을 빠르게 선택<br />지역 최적 선택 | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 |
| 하위 문제를 풀기전에 (탐욕적) 선택 먼저                      | 하위 문제 우선 해결                               |
| Top-down 방식                                                | Bottom-up 방식                                    |
| 일반적으로 빠르고 간결                                       | 좀 더 느리고 복잡                                 |

- 대표적인 탐욕 기법의 알고리즘 들

|      알고리즘       | 목적                                                   | 설명                                                         |        |
| :-----------------: | ------------------------------------------------------ | ------------------------------------------------------------ | :----: |
|        Prim         | N개의 노드에 대한 최소 신장 트리(MST) 찾기             | 서브트리를 확장하면서 MST 탐색                               | 그래프 |
|       Kruskal       |                                                        | 싸이클이 없는 서브 그래프를 확장하면서 MST 탐색              |        |
|      Dijkstra       | 주어진 정점에서 다른 정점들에 대한 최단 경로 찾음      | 주어진 정점에서 가장 가까운 정점을 찾고, 그 다음 정점을 반복해서 찾음 | 그래프 |
| Huffman tree & code | 문서의 압축을 위해 문자들의 빈 도수에 따라 코드값 부여 | 출현 빈도가 낮은 문자부터 선택해서 이진 트리를 완성하고 코드값 부여 | 문자열 |

