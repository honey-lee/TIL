# 스택1 (stack)

> - 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
> - 스택에 저장된 자료는 `선형 구조`를 갖는다
>   - 선형 구조 : 자료 간의 관계가 1대 1의 관계를 가짐
>   - 비선형 구조 : 자료 간의 관계가 1대 N의 관계를 가짐(트리 - 무수히 많은 가지로 연결되어 있을 수 있다)
> - 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다
> - **마지막에 삽입한 자료를 가장 먼저 꺼낸다** : **후입선출(LIFO, Last-In, First-Out) 혹은 FILO**
>   - 스택에 1, 2, 3 순으로 자료를 삽입한 후 꺼내면 역순으로 3, 2, 1순으로 꺼낼 수 있다. (탄창, 프링글스, 인터넷 브라우저 뒤로 가기, ctrl+z....)



## 스택의 구현

- 저장소 자체를 `스택`이라 부르기도 한다

- 파이썬에서는 리스트로 구현 가능 

- 스택에서 마지막 삽입된 원소를 `top`이라 부른다

  - 보통 -1로 초기화를 한다(공백 상태)
  - 값이 쌓여갈수록 1을 더해주고 값이 빠질 때 1을 뺀다

  

## 연산

- 삽입 : 저장소에 자료를 저장한다. `push`

  ```python
  def push(item):
      s.append(item)
  ```

- 삭제 : 저장소에서 자료를 역순으로 꺼낸다. `pop`

  ```python
  def pop():
      if len(s) == 0:
          #underflow
          #공백 검사
          return #None을 리턴한다
      else:
          #-1값을 쓰지 않아도 기본값이 가장 끝 값을 가리킨다 
          return s.pop(-1)
      	#혹은
          return s.pop(len(s)-1)
  ```

- `isEmpty` : 스택에 공백인지 확인 

- `peek` : 스택의 top에 있는 원소를 반환



## 스택 구현 고려 사항

- 1차원 배열을 사용해 구현할 경우 구현이 용이,  but 스택의 크기를 변경하기 어려움



## 스택의 응용 1) 괄호 검사

- 괄호의 종류 : 대괄호 `[]`, 중괄호 `{}`, 소괄호`()`
- 조건 
  - 왼쪽 괄호의 갯수와 오른쪽 괄호의 갯수가 같아야 한다 -> 괄호는 절대 홀수 갯수로 있을 수 없다
  - 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다
  - 괄호 사이에는 포함 관계만 존재한다  -> `({)}` 이런식으로 겹칠 수 없다
- **괄호를 조사하는 알고리즘** : 문자열에 있는 괄호를 찰례대로 조사하면서 왼쪽 괄호를 만나면 스택에 쌓고 오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지 검사한다.
  - 모든 검사가 끝나고도 스택에 괄호가 남아있으면 위의 괄호 조건에 위배되는 것이다



## 스택의 응용 2) Function call

- 프로그램에서 함수 호출과 복귀에 따른 수행 순서를 관리
  - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조 
  - 함수 실행이 끝나면 시스템 스택의 top원소를 삭제하면서 복귀 

```python
def func2():
    print('함수 2 시작')
    print('함수 2 종료')
    
def func1():
    print('함수 1 시작')
    func2()
    print('함수 1 종료')

print('메인시작')
func1()
print('메인끝')
```



## 재귀 호출

- 자기 자신을 호출하여 순환 수행되는 것 
- 일반적인 호출방식보다 프로그램의 크기를 줄이고 간단하게 작성할 수 있다
- base case와 recursive case로 이루어진다 (반드시 종료조건이 필요하다)
- 마지막에 구한 하위값을 통해 상위값을 구하는 작업을 반복 

```python
#피보나치 수열
def fibo(n):
    if n < 2:
        return n
    return fibo(n-1) + fibo(n-2)
```



## Memoization(메모이제이션)

- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 **전체적인 실행속도를 빠르게**하는 기술 
- DP(동적 계획법)의 핵심 기술이다

```PYTHON
def fibo1(n):
    global memo
    if n >= 2 and len(memo) <= n:
        memo.append(fibo1(n-1) + fibo1(n-2))
    return memo[n]
memo = [0, 1] #값을 한번 구해서 저장해둔다 
```

```python
memo2 = [-1] * 20
memo2[0] = 0
memo2[1] = 1

def fibo2(n):
    if memo2[n] == -1:
        memo2[n] = fibo2(n-1) + fibo2(n-2)
        
        return memo2[n]
```



## DP (동적 계획법)

- 동적 계획 알고리즘은 그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즈
- 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다 
- recursive 방식: fib1(), iterative방식 : fib2()
- memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 구현한 것이 보다 효율적 -> 재귀적 구조는 시스템 호출 스택을 사용하는 오버헤드 발생

```PYTHON
def fibo3(n):
    f = [0, 1]
    
    for i in range(2, n+1):
        f.append(f[i-1] + f[i-2])
    return f[n]
```



## DFS (깊이 우선 탐색)

> - 비선형 탐색의 일종
> - 비선형 구조인 그래프 구조는 그래프에 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다 
>   - 깊이 우선 탐색(DFS) : 맹목적 탐색 방법의 하나이다. 단, 중복으로 탐색하지 않기 위해 지나온 과거를 기록해야 한다. `STACK`에 기록한다
>   - 너비 우선 탐색(BFS) -> QUEUE
> - 한 요소를 `정점(vertex)`, 정점 사이를 연결하는 것이 `간선`이다. **간선으로 연결되지 않아도 이동할 수 있다.**
> - `STACK`은 방문한 곳 기록, `QUEUE`는 방문할 곳

1) 시작 정점 v를 결정하여 방문한다

2) 정점 v에 인접한 정점 중에서

- 방문하지 않은 정점w가 있으면 정점 v를 스택에 push하고 정점 w를 방문한다. 그리고 w를 v로 하여 다시 2)를 반복한다
- 방문하지 않은 정점이 없으면 탐색의 방향을 바꾸기 위해 스택을 pop하여 받은 가장 마지막 정점을 v로 하여 다시 2)를 반복한다

3) 공백이 될 때까지 2)를 반복한다

### DFS 표현 방법

```MARKDOWN
#1번 노드와 2, 3번 정점 연결되어 있고
#2번 노드와 4, 5번 정점 연결되어 있다
[[], [2, 3], [4, 5], [], []]
```

