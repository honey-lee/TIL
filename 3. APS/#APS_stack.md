# 스택1 (stack)

> - 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
> - 스택에 저장된 자료는 `선형 구조`를 갖는다
>   - 선형 구조 : 자료 간의 관계가 1대 1의 관계를 가짐
>   - 비선형 구조 : 자료 간의 관계가 1대 N의 관계를 가짐(트리 - 무수히 많은 가지로 연결되어 있을 수 있다)
> - 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다
> - **마지막에 삽입한 자료를 가장 먼저 꺼낸다** : **후입선출(LIFO, Last-In, First-Out) 혹은 FILO**
>   - 스택에 1, 2, 3 순으로 자료를 삽입한 후 꺼내면 역순으로 3, 2, 1순으로 꺼낼 수 있다. (탄창, 프링글스, 인터넷 브라우저 뒤로 가기, ctrl+z....)



## 스택의 구현

- 저장소 자체를 `스택`이라 부르기도 한다

- 파이썬에서는 리스트로 구현 가능 

- 스택에서 마지막 삽입된 원소를 `top`이라 부른다

  - 보통 -1로 초기화를 한다(공백 상태)
  - 값이 쌓여갈수록 1을 더해주고 값이 빠질 때 1을 뺀다

  

## 연산

- 삽입 : 저장소에 자료를 저장한다. `push`

  ```python
  def push(item):
      s.append(item)
  ```

- 삭제 : 저장소에서 자료를 역순으로 꺼낸다. `pop`

  ```python
  def pop():
      if len(s) == 0:
          #underflow
          #공백 검사
          return #None을 리턴한다
      else:
          #-1값을 쓰지 않아도 기본값이 가장 끝 값을 가리킨다 
          return s.pop(-1)
      	#혹은
          return s.pop(len(s)-1)
  ```

- `isEmpty` : 스택에 공백인지 확인 

- `peek` : 스택의 top에 있는 원소를 반환



## 스택 구현 고려 사항

- 1차원 배열을 사용해 구현할 경우 구현이 용이,  but 스택의 크기를 변경하기 어려움



## 괄호 검사

- 괄호의 종류 : 대괄호 `[]`, 중괄호 `{}`, 소괄호`()`
- 조건 
  - 왼쪽 괄호의 갯수와 오른쪽 괄호의 갯수가 같아야 한다 -> 괄호는 절대 홀수 갯수로 있을 수 없다
  - 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다
  - 괄호 사이에는 포함 관계만 존재한다 



## Function call

```python
def func2():
    print('함수 2 시작')
    print('함수 2 종료')
    
def func1():
    print('함수 1 시작')
    func2()
    print('함수 1 종료')
    

```



## 재귀 호출

- 자기 자신을 호출하여 순환 수행되는 것 
- 일반적인 호출방식보다 프로그램의 크기를 줄이고 간단하게 작성할 수 있다
- 반드시 종료조건이 필요하다 
- 마지막에 구한 하위값을 통해 상위값을 구하는 작업을 반복 



## DFS (깊이 우선 탐색)

> - 비선형 탐색의 일종
> - 비선형 구조인 그래프 구조는 그래프에 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다 
>   - 깊이 우선 탐색(DFS) : 맹목적 탐색 방법의 하나이다. 단, 중복으로 탐색하지 않기 위해 지나온 과거를 기록해야 한다. STACK에 기록한다
>   - 너비 우선 탐색(BFS)
> - 한 요소를 `정점(vertex)`, 정점 사이를 연결하는 것이 `간선`이다. **간선으로 연결되지 않아도 이동할 수 있다.**
> - `STACK`은 방문한 곳 기록, `QUEUE`는 방문할 곳

1) 시작 정점 v를 결정하여 방문한다

2) 정점 v에 인접한 정점 중에서

- 방문하지 않은 정점w가 있으면 정점 v를 스택에 push하고 정점 w를 방문한다. 그리고 w를 v로 하여 다시 2)를 반복한다
- 방문하지 않은 정점이 없으면 탐색의 방향을 바꾸기 위해 스택을 pop하여 받은 가장 마지막 정점을 v로 하여 다시 2)를 반복한다

3) 공백이 될 때까지 2)를 반복한다

### DFS 표현 방법

```MARKDOWN
#1번 노드와 2, 3번 정점 연결되어 있고
#2번 노드와 4, 5번 정점 연결되어 있다
[[], [2, 3], [4, 5], [], []]
```

