# 7장 - 교착상태(deadlock)

:bulb:**Deadlock**

​	✔ 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태

![캡처](7장-교착상태(deadlock).assets/캡처.PNG)

여기서 자원은 하드웨어 자원일수도, 소프트웨어 자원일수도 있다.

:bulb:Resource(자원)

​	✔ 하드웨어, 소프트웨어 등을 포함하는 개념

​	✔ ex) I/O device, CPU cycle, memory space, semphore 등

​	✔ 프로세스가 자원을 사용하는 절차

​		- Request(요청), Allocate(획득), Use(사용), Release(반납)

:bulb:Deadlock Example

​	프로세스0 은 A라는 자원을 획득한 후 B를 획득하려고 하고,

​	프로세스1 은 B라는 자원을 획득한 후 A를 획득하려고 한다.

​	이때 0번과 1번이 각각 첫 번째 자원을 획득한 후에는 서로가 서로의 자원을 내놓으라고 하게 되고, 둘 중 하나는 자신의 자원을 포기해야 한다 => 데드락 상황!



## Deadlock 발생의 네 가지 조건

✔ Mutual exclusion(상호배타적)

​	- 매 순간 하나의 프로세스만이 자원을 사용할 수 있음(자원을 가진 프로세스가 독점적으로 사용)

✔ No preemption(비선점, 빼앗기지 않음)

 - 프로세스는 자원을 스스로 내어놓을 뿐 강제로 **빼앗기지 않음**

✔ Hold and wait(보유대기)

​	- 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음

✔ Circular wait(순환대기)

 - 자원을 기다리는 프로세스간에 사이클이 형성되어야 함
 - 프로세스 P0, P1, ... Pn 이 있을 때
   	- P0는 P1이 가진 자원을 기다림
      	- P1은 P2가 가진 자원을 기다림
   	- Pn-1은 Pn이 가진 자원을 기다림
   	- Pn은 P0이 가진 자원을 기다림

시험문제 빈출



## Resource-Allocation Graph(자원할당그래프)

데드락이 발생했는지 알아보기 위한 그래프

![캡처1](7장-교착상태(deadlock).assets/캡처1.PNG)



✔ 원형: 프로세스

✔ 사각형: 자원

✔ 사각형 안의 점: 해당 자원의 개수 => R2 자원은 2개, R4 자원은 3개

✔ 화살표

- 자원에서 프로세스쪽으로: 자원이 프로세스에 속해있다.
- 프로세스에서 자원으로: 프로세스가 자원을 요청한다.

**그림 해설**

P1은 2번 자원을 가지고 있으면서 1번 자원을 기다리고 있는데, 1번 자원은 P2가 가지고 있다. P2는 2번 자원을 가지고 있으면서 3번 자원을 기다리는데, 3번 자원은 P3가 가지고 있다.

이 그래프가 데드락인지 아닌지는 그래프에 cycle이 있는지 유무로 갈린다. (위 그림은 cycle이 없음)

✔ **cycle이 없으면 데드락이 아니다.**

✔ cycle이 있으면

- 자원당 인스턴스가 하나밖에 없으면 cycle은 곧 데드락을 의미한다.
- 자원당 인스턴스가 여러 개면 데드락의 가능성이 있다.

![캡처2](7장-교착상태(deadlock).assets/캡처2-1625856628868.PNG)

✔ 왼쪽 상황은 사이클이 두 개 있으므로 자원을 확인해봐야 한다. => R2 자원을 P1과 P2가 가지고 있으면서 P3가 또 R2 자원을 요청하고 있으므로 데드락이다.

✔ 오른쪽 상황은 사이클이 하나 있으므로 자원을 확인해봐야 한다. => P1은 R1을, P3은 R2를 요청하고 있으므로 데드락처럼 보이지만 P2, P4가 데드락에 연루되어 있지 않아 자원을 사용하고 반납을 하면 P1과 P3도 자원을 획득할 수 있으므로 데드락이 아니다.

뒤에서 테이블 형태로 데드락을 체크하는 방법을 알아본다.



## Deadlock의 처리 방법

:bulb: Deadlock Prevention(비효율적)

- 자원 할당 시 Deadlock의 네 가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것
  - 자원이 필요한 경우 보유 자원을 모두 놓고 다시 요청하기, 자원을 빼앗아 올 수 있게 하기, 자원에 할당 순서 정하기, ...

:bulb: Deadlock Avoidance(최악의 상황을 가정, 아주 안전하게 가자)

- 자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 전혀 없는 경우에만 자원을 할당

- 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원 할당

- **각 자원이 단 하나씩만 있을 경우** 앞서 알아본 그래프를 이용하여 cycle이 형성될 가능성이 있는 경우 자원을 할당하지 않는다.

- **각 자원이 여러 개일 경우** => Banker's Algorithm

  ![캡처3](7장-교착상태(deadlock).assets/캡처3.PNG)

  항상 최대 요청을 가정하고, 프로세스의 최대 요청이 가용 자원 이하여야 요청을 받아들임. 처음에 P0 요청은 받아들이지 않고, P1 요청은 받아들임. 어떤 프로세스가 종료되어 가용 자원(available)이 새로운 프로세스의 Need보다 커질 때에만 새로운 프로세스의 요청을 받아들인다!

:bulb: Deadlock Detection and recovery(낙관적인 접근)

- Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견시 recover

- 자원당 인스턴스가 하나인 경우에는 자원할당 그래프 이용

- 여러 개인 경우 테이블 이용(하나인 경우에도 테이블 사용 가능)

- n개의 프로세스에서 자원이 하나씩만 있는 경우, 사이클이 존재하는지 확인하려면 O(n^2)의 시간이 필요하다. (프로세스 n개, 화살표 최대 n-1개)

  ![캡처4](7장-교착상태(deadlock).assets/캡처4.PNG)

- 자원이 여러 개인 경우, 테이블에서 최대한 낙관적으로 접근한다.

  ![캡처5](7장-교착상태(deadlock).assets/캡처5.PNG)

  처음에 P1의 요청은 거부가 될 것이다. 그러나 P0, P2 등의 프로세스가 종료되어 자원이 반납된 후에는 P1의 요청이 받아들여진다. 이렇게 낙관적인 상황을 가정했을 때 모든 프로세스가 문제 없이 동작할 수 있는 경우 deadlock이 없는 것으로 여긴다.

  만약 위 그림에서 P2가 C 하나를 요청했다고 하면, P0를 제외한 어떤 프로세스의 요청도 받아들일 수 없게 되고, 종료될 수 있는  프로세스는 P0 하나로, P0가 종료되더라도 다른 프로세스의 요청은 받아들일 수가 없으므로 프로세스 진행이 되지 않아 deadlock이 된다.

- Deadlock이 발견되면 Recovery를 한다.

  .✔  Recovery 방법

  - Process termination
    - 데드락에 연루된 모든 프로세스를 죽인다.
    - 데드락에 연루된 프로세스를 데드락이 없어질 때까지 하나씩 죽여본다.
  - Resource Preemption
    - 데드락에 연루된 프로세스로부터 자원을 빼앗는 방법으로, 비용을 최소화하기 위해 데드락에 연루된 프로세스 중에서 victim process를 선정하여 자원을 빼앗는다.
    - 문제점1 - 계속 같은 프로세스로부터 자원을 빼앗을 경우 똑같은 deadlock이 발생할 수 있다.
    - 문제점2 - 자원을 빼앗기는 프로세스는 starvation 문제 발생(영원히 실행되지 않음)
    - 따라서 자원을 빼앗긴 횟수 등을 고려하여 victim을 선정하는 등 같은 프로세스만 자원을 빼앗기지 않도록 어떤 패턴을 만들어야 한다.

:bulb: **Deadlock Ignorance**

- Deadlock을 시스템이 책임지지 않음(데드락이 일어나지 않는다고 생각)
- UNIX, Windows를 포함한 대부분의 범용 OS가 채택
- deadlock은 드물게 일어나는 예외상황으로, deadlock에 대한 조치 자체가 더 큰 overhead일 수 있음
- 만약 시스템에 deadlock이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 process를 죽이는 등의 방법으로 대처



