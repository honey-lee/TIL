# Network 🌍

*성공과 실패를 결정하는 1%의 네트워크 원리, Tsutomu Tone 저*

## Chapter 05 서버측의 LAN에는 무엇이 있는가?

> - 방화벽 : 네트워크를 외부에서의 공격으로부터 지키기 위해 고안된 구조의 하나로 이런 종류의 구조 중에는 최초로 등장한 것 
> - POP
> - 캐시 서버
> - 패킷 필터링형
> - UDP
> - 프록시 : 클라이언트와 웹 서버 사이에 설치하여 액세스 동작을 중개하는 구조 

[TOC]

### 📌01 웹 서버의 설치 장소

___

> 서버는 어디에? 사내 혹은 데이터 센터에

- 이전의 서버 설치 형태 : 사내의 LAN에 서버를 설치하고 인터넷에서 직접 접근, 이때 패킷은 가장 가까운 POP에 있는 라우터, 액세스 회선, 서버측 라우터를 경유해 서버 머신에 그대로 도착 (이 때 패킷은 필터링 없이 그대로 중계됨)
- **방화벽 분리** : 패킷을 검사하고 통과를 허가한 패킷만 중계



### 📌 02 방화벽의 원리와 동작

#### 1 패킷 필터링형

- 방화벽의 기본 개념 : 특정 서버와 해당 서버안의 특정 애플리케이션에 액세스하는 패킷만 통과시키고 그 외의 패킷을 차단
- 패킷 필터링형 : 성능, 가격, 사용 편의성 등의 이유로 가장 많이 보급된 필터링 형태

#### 2 패킷 필터링의 조건 설정 개념

- 패킷의 헤더에 포함된 통신 동작을 제어하는 다양한 제어 정보를 통해 정보를 얻음
- 아래 예시는 인터넷에서 웹 서버측으로 패킷을 전송하는 사례 

1. 수신처 IP주소와 송신처 IP 주소에 따라 시점과 종점을 판단
   1. 이 때 송신측 주소와 관계없이 수신처 주소가 웹 서버라면 통과 시킨다
2. 패킷을 받으면 정확하게 도착했는지를 송신측에 알리는 수신확인 응답의 구조 작용 (웹 서버 ➡ 인터넷)
3. 포트 번호를 대조하여 웹 서버 내의 특정 애플리케이션에 대한 접근만 허용
4. TCP 헤더에 있는 컨트롤 비트를 사용해 액세스 방향을 판단하여 웹 서버에서 인터넷으로 흐르는 패킷 정지 
   1. 웹의 동작은 TCP 프로토콜을 사용하여 양방향으로 패킷이 흐르기 때문에 패킷이 흐르는 방향이 아니라 액세스 방향을 판단하여 정지해야함
   2. TCP는 최초에 행하는 접속 단계의 동작에서 3개의 패킷이 흐르는데, 최초의 패킷만 TCP 컨트롤 비트의 SYN이라는 비트가 1로되고, ACK 라는 비트는 0
   3. 다른 패킷에서 같은 값을 취하는 경우는 없으므로 이 값을 조사해서 두 번째 이후의 패킷을 판별 가능 



#### 3 방화벽 통과

> - 패킷 필터링은 라우터의 패킷 중계 기능 중에서 부가 기능 

- 방화벽 통과 시 : 그 이상의 특별한 구조는 없음 
- 방화벽에서 차단 시 : 패킷을 버리고 버린 기록을 남김 ➡ 향후 부정 침입 대첵에 도움이 될 수 있음



#### 4 방화벽으로 막을 수 없는 공격

> - 방화벽은 패킷 흐름의 시점과 종점을 판단해 차단과 통과 여부를 결정하는데 시점과 종점만으로 위험한 패킷을 전부 판단할 수 있는 것은 아님
> - 패킷 중에 특수한 악성 데이터가 포함되어 있어도 통과시켜 버림
> - 이런 상황에 두 가지 대처법이 있음

1. 버그를 고쳐서 다운되지 않도록 하는 것 : 항상 새로운 버전으로 갱신하는 것이 중요 (새로운 버그에 대처)
2. 패킷의 내용을 조사하여 위험한 데이터가 포함되어 있는 경우에 패킷을 차단하도록 장치나 소프트웨어를 방화벽과는 별도로 준비하는 방법 



### 📌03 복수 서버에 리퀘스트를 분배한 서버의 부하 분산 

#### 1 분산처리

- 분산 처리 : 복수의 서버를 사용하여 처리를 분담하는 방법, 서버 한대 당 처리량을 줄임
- 클라이언트가 보내는 리퀘스트를 웹 서버에 분배하는 구조 중 DNS 서버에서 분배하는 방법이 가장 간단 
  - 서버에 액세스할 때 DNS 서버에 조회하여 IP주소를 조사
- **라운드 로빈** : 복수의 서버가 있을 때 순환하며 한 서버씩 응답시키는 방식, 복수의 서버에 균등하게 액세스 분산
  - 결점 : 고장난 웹 서버가 있는 경우에도 그대로 응답시킴 
  - 웹 서버가 변하면서 대화가 도중에 끊기는 경우 발생할 수 있음
  - 이러한 상태를 피하고자 부하분산장치 고안됨

#### 2 부하 분산 장치를 이용한 복수의 웹 서버로 분할

- 부하 분산 장치에 이름을 붙이고 (www.lab.cyber.co.kr) 그 이름에 대응하여 부하 분산장치의 IP 주소를 DNS 서버에 등록
- 클라이언트는 웹 서버에 리퀘스트 메시지 전송
- 웹 서버와 정기적인 정보 교환을 통해  CPU나 메모리의 사용률 등을 수집하고 이것을 바탕으로 어느 웹 서버의 부하가 낮은지 판단하거나 시험 패킷을 웹 서버에 보내 응답시간으로 부하를 판단
- 대화가 복수의 페이지에 걸쳐있을 때는 웹 서버의 부하와 관계없이 이전의 리퀘스트와 같은 웹 서버에 전송 



### 📌04 캐시 서버를 이용한 서버의 부하 분산 

- 캐시 서버 : 데이터베이스 서버와 웹 서버 등 역할에 따라 서버를 나누는 방법
- 프록시라는 구조를 사용하여 데이터를 캐시에 저장
- 프록시는 웹 서버와 클라이언트 서버 사이에 들어가서 웹 서버에 대한 액세스 동작을 중개하는 역할, 중개 시 웹 서버에서 받은 데이터를 디스크에 저장해두고 웹 서버를 대신하여 클라이언트에 반송하는 기능 (캐시)
- 캐시 서버의 동작
  - 데이터가 저장되어 있지 않은 경우 
    1. 어느 웹 서버에 리퀘스트를 보낼지 확인하고 헤더에 via를 추가하여 전송
    2. 캐시 서버가 클라이언트의 입장에서 웹 서버와 통신하고 웹으로부터 받은 데이터를 클라이언트에 전송
  - 데이터가 저장되어 있는 경우 
    1. 웹 서버의 데이터가 특정 일자로 부터 변경되었는지 확인하기 위해 if-modified-since 라는 필드를 헤더에 추가하여 전송한다
    2. 웹 서버에서 변경여부 확인
    3. 변경 사항이 없으면 캐시에 저장된 데이터 전송
- 포워드 프록시 : 클라이언트에 두는 캐시 서버
- 리버스 프록시 : 포워드 프록시를 개량한 개념
  - 브라우저에 프록시를 설정하지 않아도 사용할 수 있도록 개량
- 트랜스페어런트 프록시 : 패킷의 맨 앞에 있는 IP 헤더를 조사하여 액세스 대상 웹 서버가 어디 있는지 찾는 방법
  - 보통의 리퀘스트 메시지를 전송할 수 있으므로 포워드 프록시처럼 브라우저에 설정할 필요 없음
  - 전송 대상을 캐시 서버에 전송할 필요 없이 어느 웹 서버에서나 전송할 수 있음