영상: [컴퓨터시스템구조 CSA-8 Part-1](https://youtu.be/y0ZqhmmWRks?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

# 8장 중앙처리장치

[toc]

## [제 8장 Part-1](https://youtu.be/y0ZqhmmWRks?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### CPU 주요 요소

- 기억장치
  - 레지스터 집합 : 기본 컴퓨터가 가지고 있는 여러 레지스터 (상세 내용 5장 참고)
  - 데이터 임시 저장 장소 : 메인 메모리에 저장된 데이터와 프로그램이 수행되기 위해 CPU로 옮겨오는데 그 때 데이터를 임시로 저장하는 장소 
- 제어장치 : 명령어의 종류에 따라 연산 타이밍에 필요로 하는 제어를 수행함
  - CPU 명령어 처리 회로의 집합
  - 논리 게이트와 요소들로 구성 (decode, encode, 버퍼 등)
  - 명령어에 따라서 연산 제어 수행
- 연산장치
  - ALU
  - 산술 연산, 논리 연산, 시프트 연산 수행 

### 범용 레지스터 구조 ( General Register Organization)

> - ALU와 레지스터 집합간의 관계가 중요: 어떤 레지스터(source)에서 데이터를 받아서 연산한 후 어떤 레지스터(destination)로 보낼건지

- 공용 ALU를 가진 레지스터 집합

  - 7개의 범용 레지스터 : 어떤 레지스터가 소스가 될건지 결정하기 위해 멀티 플렉서 사용 
  - Bus : 데이터가 전달되는 통로 
  - OPR : 연산의 종류를 결정 (+, -, *, / 등)
  - 3 x 8 디코더 : 연산의 결과가 어떤 레지스터로 들어갈지 결정
  - **하나의 연산을 하기 위해서는 4개의 비트가 결정되어야 한다, SELA, SELB, OPR, SELD**

  <img src="8장-중앙-처리-장치.assets/image-20210803233659924.png" alt="image-20210803233659924" style="zoom: 150%;" />

- 제어 워드 집합

  - SELA, SELB : ALU 입력 결정

  - SELD : ALU 출력 저장소 결정

  - OPR : 연산의 종류 지정

    ![image-20210803234327236](8장-중앙-처리-장치.assets/image-20210803234327236.png)

    ![image-20210803234428143](8장-중앙-처리-장치.assets/image-20210803234428143.png)



- 레지스터와 연산 인코딩

  ![image-20210803234958647](8장-중앙-처리-장치.assets/image-20210803234958647.png)

  ![image-20210803235151024](8장-중앙-처리-장치.assets/image-20210803235151024.png)



## [제 8장 Part-2](https://youtu.be/9OyG5YWwLCY?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 스택 구조 (Stack Organization)

> - 스택은 메모리의 일부분만을 사용해서 만들 수도 있고, 레지스터 만을 사용해서 만들수도 있다. 
> - 대부분의 CPU는 레지스터의 수가 많지 않아 레지스터만으로 스택을 만들기는 쉽지 않음

- 레지스터 스택

  ![image-20210804091603687](8장-중앙-처리-장치.assets/image-20210804091603687.png)

  - PUSH 동작 : 쌓여있는 데이터의 가장 꼭대기에 새로운 데이터를 쌓음

    - SP ⬅ SP + 1

      M[SP] ⬅ DR 

      IF (SP = 0) then (FULL ⬅ 1)

      EMPTY ⬅ 0

  - POP 동작

    - DR ⬅ M[SP]

      SP ⬅ SP - 1

      IF (SP = 0) the (EMPTY ⬅ 1)

      FULL ⬅ 0

  - SP (Stack Pointer) : 현재 스택의 가장 상단을 가리키면서 표시하는 레지스터, 새로운 데이터가 추가될때마다 값이 1씩 증가

  - Full : 스택에 더 이상 공간이 없을 때 값이 1 (플립플롭)

  - Empty : 스택이 비어있을 때 값이 1 (플립플롭)



- 메모리 스택 : 메인 메모리의 일부를 떼서 스택으로 사용함, 레지스터 스택과 기본적인 구조와 동작은 같다 

  ![image-20210804092257809](8장-중앙-처리-장치.assets/image-20210804092257809.png)

  - 다운워드 그로잉 방식으로 설계된 스택은 데이터가 들어오면 SP가 감소한다. 설계방식의 차이일 뿐 레지스터 스택과 메모리 스택의 차이점은 아니다. 인텔 설계는 대부분 다운워드 그로잉 방식을 사용한다 
  - PUSH 동작
    - SP ⬅ SP - 1
  - POP 동작
    - SP ⬅ SP + 1

- ***메모리 세그먼트*** : 프로그램을 동작시키기 위해 CPU가 일정한 크기로 잘라놓은 단위 

  - 어떤 프로그램이든 3개의 메모리 세그먼트를 가진다, 3개의 세그먼트를 합쳐서 하나의 프로세스가 된다 
    - Code : 프로그램의 코드가 들어간다 
    - Data : 프로그램에서 사용하는 데이터가 들어간다
    - Stack (Heap)
      - 어셈블리어에서는 Heap이라는 용어로만 사용 
  - 세그먼트의 크기
    - MS-DOS / Windows : 64KB
    - UNIX/Linux : N x 1KB 블록

- 스택 오버플로우 : 스택의 크기를 벗어나는 SP 값

  - protected mode에서 발생
  - 다른 영역의 메모리를 침범하지 못하게 함 

- 연산자 표기 방식 : Stack 사용시에 Prefix 혹은 Postfix 방식을 사용하며 Postfix방식이 가장 많이 사용됨

  - Infix  `A + B`

  - Prefix (polish) `+AB`

  - Postfix (reverse polish) `AB+`

    - A * B + C * D ➡ AB* CD* +

      ![image-20210804183211849](8장-중앙-처리-장치.assets/image-20210804183211849.png)

## [제 8장 Part-3](https://youtu.be/C853I1DGvbU?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 명령어 형식 (Instruction Format)

> - 어떤 식으로 레지스터를 사용해서 연산을 하는지를 표시

- 단일 누산기 구조 (Accumulator)

  > - 누산기에 의해 명령이 수행되는 구조 
  > - 묵시적으로 누산기를 또 다른 operand로 취급

  - ADD X
  - AC ⬅ AC + M[X]

- 범용 레지스터 구조

  > - operand를 전부 표시하며, operand의 갯수에 따라 `one address`, `two address`, `three address` 방식이라고 한다
  > - `3주소 명령어` : source와 destination 표시
  > - `2주소 명령어` : 2개의 레지스터나 메모리 주소로 표시
  > - `1주소 명령어` : accumulator

  - ADD R1, R2, R3 : R1 ⬅ R2 + R3
  - ADD R1, R2 : R1 ⬅ R1 + R2
  - MOV R1, R2 : R1 ⬅ R2 (transfer 명령)
  - ADD R1, X : R1 ⬅ R1 + M[X] (메모리와 레지스터를 사용한 연산)

- 스택 구조

  > - stack을 기반으로 하는 구조
  > - 무주소 명령어

  - PUSH X
  - ADD



- **그러면 어떤 경우에 1주소, 2주소, 3주소 혹은 무주소를 쓸까**

  - 아래의 식이 있다고 할때

  - X = (A + B) * (C + D)

  - 어떤 명령어를 쓰느냐에 따라서 다르게 표현되고 주소가 낮을수록 연산 과정은 길어진다

  - (참고) RISC 명령어는 모든 주소를 레지스터에 넣고 레지스터끼리만 연산하는 방식이다

    ![image-20210804184528468](8장-중앙-처리-장치.assets/image-20210804184528468.png)

### 어드레싱 모드 (Addressing Mode)

> - CPU에서 다양한 어드레싱 모드 사용됨
> - 가장 대표적인 어드레싱 모드는 직접 모드와 간접 모드

- 다양한 어드레싱 모드의 사용 이유

  - Pointer, counter, indexing 기능 제공
  - 프로그램 재배치 편의 제공 ➡ 프로그래밍의 융통성 제공
    - 물리적인 주소에 구애받지 않고 절대주소를 여러가지 상대 주소로 제공하기 위한 것 
  - 명령어 주소필드 최소화

- 명령어 형식 with mode field

  - mode : 주소 비트를 나타내는 필드

  ![image-20210804185338124](8장-중앙-처리-장치.assets/image-20210804185338124.png)

- Implied 모드

  - 피연산자가 묵시적으로 이미 정의된 경우

- Immediate 모드

  - 피연산자가 명령어 자체에 있는 경우
  - 어떠한 주소값을 줘서 레지스터에 바로 저장되도록 함

- 레지스터 (직접)모드

  - CPU내 레지스터에 피연산자 존재

- 레지스터 간접 모드

  - 명령어가 피연산자의 주소를 가지고 있는 레지스터를 지정
  - 직접 주소보다 적은 어드레스 비트 사용

- 자동증가 / 자동감소 모드

  - 메모리 접근 후 레지스터 값이 자동으로 증가/감소

- **직접 주소 모드**

  - 명령어의 주소 부분이 유효 주소(EA)를 표시

- **간접 주소 모드**

  - 명령어 주소 부분에 유호주소를 지정하는 주소 표시
  - 다양한 간접 주소 모드 사용
  - 유효주소의 계산
    - 유효 주소(EA) = 명령어 주소 부분 (ADDR) + CPU내 특정 레지스터 값 

  1. 상대 주소 모드

     - 유효 주소 = 주소 필드값과 프로그램 카운터의 합 (EA = ADDR + PC)
     - 주로 운영체제에서 사용하는 프로그램에서 사용됨
     - 실제 많이 사용되는 것은 2번과 3번 

  2. 인덱스 어드레싱 모드

     - 유효 주소 = 주소 필드값과 인덱스 레지스터 값의 합 (EA = ADDR + XR)

       ![image-20210804190045875](8장-중앙-처리-장치.assets/image-20210804190045875.png)

     - 배열의 각 원소에 대한 인덱스 주소 계산에 사용

  3. 베이스 레지스터 어드레싱 모드

     - 유효 주소 = 주소필드값과 베이스 레지스터값의 합 (EA = ADDR + BR)

       ![image-20210804190059390](8장-중앙-처리-장치.assets/image-20210804190059390.png)

- 어드레싱 모드의 실제 예

  - Load to AC 옆에 Mode가 있고 201 에는 Address 500이 지정되어 있음
  - 직접주소 모드 : 유효 주소는 500, AC에는 500번에 들어있는 주소값이 800
  - Immediate mode : 주소자리에 피연산자니까 201, AC에 500
  - 간접 주소 모드 : 500번에 주소 800이 있고, 800을 찾아가면 300
  - 상대 주소 모드 : adress + PC = 702, 702에 있는 325
  - Autoincrement : R1값 (400)이 자동증가
  - Autodecrement : R1값 감소 ➡ 399
  
  ![image-20210804190751770](8장-중앙-처리-장치.assets/image-20210804190751770.png)

## [제 8장 Part-4](https://youtu.be/TEwjdwXbQfw?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 데이터 전송과 처리 (Data Transfer and Manipulation)

- 데이터 처리 명령어 (ALU 실행)

  - 산술 명령어

  - 논리 연산 및 비트 처리 명령어

  - 시프트 명령어

    ![image-20210804191745082](8장-중앙-처리-장치.assets/image-20210804191745082.png)

### 프로그램 제어 (Program Control)

- 상태 비트 조건

  - C : ALU 출력 캐리값

  - S : AC의 부호비트

  - Z : AC값의 zero 여부

  - V : 연산 결과 오버플로우 여부

    ![image-20210804191933801](8장-중앙-처리-장치.assets/image-20210804191933801.png)

- 조건부 분기 명령어

  - 상태 비트에 따라서 분기

    - unsigned : 부호가 없음
    - signed : 부호가 있음 

    ![image-20210804194023462](8장-중앙-처리-장치.assets/image-20210804194023462.png)

- 서브루틴 Call : 복귀주소를 스택에 저장

  ```markdown
  SP <- SP - 1
  M[SP] <- PC
  PC <- effective address
  
  return
  
  PC <- M[SP]
  SP <- SP + 1
  ```

- 순환 서브루틴 : 서브루틴이 자기 자신을 호출 (재귀)

  - 순환 call이 return 주소를 지워버리는 것을 방지하기 위하여 스택에 return 주소를 저장 

- 프로그램 인터럽트

  - 서브루틴과의 차이점 
    - 시스템 내/외부적 신호에 의해 프로그램 진행 변경
    - 인터럽트 처리 루틴의 주소는 하드웨어 적으로 결정되어 있음
    - PC값이 아니라 CPU의 다른 상태를 나타내는 정보도 메모리에 저장 (C, V)
  - PSW (Program Status Word)
    - 인터럽트가 발생될 때 저장하는 CPU 정보
    - PSW로 저장되는 데이터
      1. 프로그램 카운터의 값
      2. 모든 레지스터의 값
      3. 상태 조건 비트(C, S, V, Z)

- 인터럽트의 형태

  - 외부 인터럽트 : 입출력 장치, 타이밍 장치, 전원 등 외부 요소에 의해 발생
  - 내부 인터럽트 : 불법적인 명령이나 데이터를 사용할 때 발생, overflow, 0division, segment fault 등
  - 소프트웨어 인터럽트 : 명령어의 수행에 의해 발생, Supervisor call 명령, system call

  

## [제 8장 Part-5](https://youtu.be/OWJTkYKwdno?list=PLc8fQ-m7b1hD4jqccMlfQpWgDVdalXFbH)

### 간소화된 명령어 집합 컴퓨터 (RISC)

- RISC (Reduced Instruction Set Computer) 개요

  - 1980년 A.Patterson 교수가 설계 
  - CISC(Complex Instruction Set Computer)에 비해 새로운 설계 개념 제시
  - 새로운 마이크로 아키텍쳐와 명령어 구조 제시
  - MIPS, ALPHA, PowerPC, SPARC, PA-RISC : 대형 CPU 제조사들이 사용하고 좋은 효율을 냈음
  - 일반적으로 상용화된 컴퓨터는 CISC 사용 중
  - 하지만 PC의 범주를 벗어나면 거의 대부분 RISC 프로세스 사용 (중, 대형 컴퓨터)

  | CISC                                                         | RISC                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | - 많은 수의 명령어<br />- 특별한 명령을 수행하는 일부 명령어는 자주 사용되지 않음<br />- 다양한 어드레싱 모드 사용<br />- 가변 길이 명령어 형식<br />- 메모리에서 피연산자 처리 | - 상대적으로 적은 수의 명령어<br />- 상대적으로 적은 수의 어드레싱 모드<br />- 메모리 참조는 load/store 명령으로만 제한<br />- 모든 동작은 CPU내 레지스터에서 수행<br />- 고정된 길이의 명령어 형식 사용<br />- 단일 사이클의 명령어 실행<br />- 하드와이어 제어방식 사용 |

  

